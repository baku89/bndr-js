# ガイド

## Emitter

Bndr における Emitter とは、単一の型のイベントを発火するオブジェクトを指します。このライブラリにおける最も基本的かつ中心的な概念です。

Window、HTMLElement、EventEmitter といったオブジェクトは、多くの場合、複数の種類のイベントを発火し、`addEventListener(eventName, callback)`のような形でイベントリスナーを登録します。一方 Bndr における Emitter はこれらとは異なり、常に単一のタイプのイベントのみを発火します。つまり、イベント名を区別する必要が無いため、`on(callback)`のようにイベントリスナーを登録することになります。

Bndr では、ポインターやキーボード、MIDI といった入力デバイスの種類ごとに、そのデバイスからのあらゆる入力を扱うための最も一般的なイベント型と紐づけられた Emitter が用意されています。その入力のうち、特定のものにのみ反応したり、イベントオブジェクトから値を取り出すには、`filter` や `map` などをメゾッドチェーン状に繋げたり組み合わせます。必要な型の Emitter を得たところで、`on` メソッドを使ってコールバック関数を登録します。

例えば、マウスやタッチ、スタイラス入力に関するイベントには`pointermove`や`pointerdown` などがありますが、Bndr におけるポインター入力を扱うオブジェクトを返す関数 `pointer()` は、それらのイベントを区別せずに`PointerEvent` 型のイベントを発火し続けます。そのうち「マウスが押された瞬間」にのみ発火するエミッターを得るには、以下のように行います。

```ts
import * as Bndr from 'bndr-js'

const pointer: Bndr<PointerEvent> = Bndr.pointer()
const mousedown: Bndr<PointerEvent> = Bndr.filter(
	e => e.pointerType === 'mouse' && e.type === 'pointerdown'
)

mousedown.on(e => console.log('Mouse pressed'))
```

ー
Bndr では、良く使うフィルターや変換処理をビルトインで提供しているため、上記のコードは以下のように一行で書くこともできます。

```ts
Bndr.mouse().down().on(e => console.log('Mouse pressed')
```

このような設計をとる利点は、一つのコールバック関数の中でイベントを無視するロジックや必要な値を取り出す処理を書くことなく、**その型 Emitter が発火した際にどのような副作用を起こすか**にのみ関心を分離することにあります。また、イベントが発火し、伝搬・変換する一連の処理を、Emitter というオブジェクトを中心としたモジュラー性の高い形で記述することで、コードの見通しを良くすることに繋がります。Bndr における処理は、Max/MSP や Quartz Composer、TouchDesigner などのビジュアルプログラミング環境においてパッチを組み合わせる様子にも似ています。ノードやパッチを組み合わせて一つの音楽やビジュアルを作り出すように、Bndr においても Emitter を組み合わせることで、所定のタイミングある型のイベントを発火するオブジェクトを構築することができます。

## Emitter の種類

Emitter には、おおよそ以下のような種類があります。

- **ジェネレーター**: デバイスや通信など外部の入力を受け取り、それをイベントとして発火する Emitter です。例えば、`pointer`、`keyboard`、`midi` 関数が返すオブジェクトがこれに当たります。
- **フィルター**: ある単一の Emitter が発火したイベントを監視し、条件に応じてそれを無視するか、あるいはペイロードの値を変換したり、ディレイやスムージングといった時間的な処理など行った上で発火する Emitter です。既存の Emitter に対して`filter`、`map`、`delay`、`throttle`、`lerp` などのメソッドを使って生成することができます。
- **コンビネーター**: 複数の Emitter が発火したイベントを組み合わせ、新たなイベントとして発火する Emitter です。`merge`、`combine` などのメソッドを使って生成することができます。

これらは厳密には区別されていません。フィルターの Emitter は、上流からの発火が無くとも `emitter.emit(value)` で手動で発火することも出来ます。

## ステートフルな Emitter

また、Emitter には状態を持つものと持たないものがあります。例えば、`Bndr.pointer()` は状態を持たない一方で、`Bndr.pointer().down()` は、ポインターが押された瞬間を検知するために、直前の状態を保持しています。また、 `fold` メゾッドで生成される Emitter なども状態を持ちます。次の例は、ポインターが押された回数をカウントする Emitter です。

```ts
const counter = Bndr.pointer()
	.down()
	.fold(count => count++, 0)
```

ステートフルな Emitter は、内部状態を外部から直接参照したり変更することは出来ません。その代わりに、`reset()` メソッドを使って内部状態をリセットすることができます。

`lerp` や`delay`といった、時間的な処理を行うメソッドを使って生成される Emitter もステートフルです。上流の Emitter が発火されると、その値を内部状態として保持し、`lerp`であれば値の補間が収まるまで継続的に発火し、`delay`の場合指定時間後に発火しますが、`reset`メゾッドを用いることで内部状態としてのスケジューラーをリセットし、以後の発火をキャンセルすることができます。
